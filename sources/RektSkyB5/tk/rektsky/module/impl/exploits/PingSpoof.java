/*
 * Decompiled with CFR 0.152.
 */
package tk.rektsky.module.impl.exploits;

import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.Map;
import java.util.Queue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;
import net.minecraft.network.play.server.S01PacketJoinGame;
import net.minecraft.network.play.server.S07PacketRespawn;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import org.greenrobot.eventbus.Subscribe;
import tk.rektsky.event.impl.PacketReceiveEvent;
import tk.rektsky.event.impl.PacketSentEvent;
import tk.rektsky.event.impl.WorldTickEvent;
import tk.rektsky.module.Category;
import tk.rektsky.module.Module;
import tk.rektsky.module.ModulesManager;
import tk.rektsky.module.impl.exploits.BoatBoost;
import tk.rektsky.module.settings.IntSetting;

public class PingSpoof
extends Module {
    private Map<Integer, Queue<Packet<?>>> queue = new HashMap();
    public IntSetting delay = new IntSetting("Delay (Ticks)", 0, 400, 100);
    public int ticks = 0;
    private boolean waitingForReset = false;

    public PingSpoof() {
        super("PingSpoof", "Makes your ping higher (Better for anticheat bypass)", Category.EXPLOIT);
    }

    @Override
    public void onEnable() {
        this.ticks = 0;
        this.waitingForReset = true;
        this.queue.clear();
    }

    @Override
    public void onDisable() {
    }

    @Subscribe
    public void onWorldTick(WorldTickEvent event) {
        ++this.ticks;
        if (this.ticks % 1000 == 0 || this.waitingForReset) {
            if (ModulesManager.getModuleByClass(BoatBoost.class).leaveTicks <= 100) {
                this.waitingForReset = false;
                for (int i2 = 0; i2 < 4; ++i2) {
                    int tick = this.ticks + i2;
                    if (!this.queue.containsKey(tick)) continue;
                    Queue<Packet<?>> packets = this.queue.get(tick);
                    while (!packets.isEmpty()) {
                        Packet<?> poll = packets.poll();
                        this.mc.thePlayer.sendQueue.addToSendQueueSilent(poll);
                    }
                }
            } else {
                this.waitingForReset = true;
            }
        }
        if (this.queue.containsKey(this.ticks)) {
            Queue<Packet<?>> packets = this.queue.get(this.ticks);
            while (!packets.isEmpty()) {
                this.mc.thePlayer.sendQueue.addToSendQueueSilent(packets.poll());
            }
        }
    }

    @Subscribe
    public void onWorldChange(PacketReceiveEvent event) {
        if (event.getPacket() instanceof S07PacketRespawn || event.getPacket() instanceof S01PacketJoinGame) {
            this.queue.clear();
        }
        if (event.getPacket() instanceof S08PacketPlayerPosLook) {
            for (int i2 = 0; i2 < this.delay.getValue(); ++i2) {
                int tick = this.ticks + i2;
                if (!this.queue.containsKey(tick)) continue;
                Queue<Packet<?>> packets = this.queue.get(tick);
                while (!packets.isEmpty()) {
                    this.mc.thePlayer.sendQueue.addToSendQueueSilent(packets.poll());
                }
            }
            this.ticks += this.delay.getValue().intValue();
        }
    }

    @Subscribe
    public void onPacket(PacketSentEvent event) {
        if (event.getPacket() instanceof C0FPacketConfirmTransaction || event.getPacket() instanceof C00PacketKeepAlive) {
            event.setCanceled(true);
            this.addToQueue(event.getPacket());
        }
        if (event.getPacket() instanceof C03PacketPlayer) {
            // empty if block
        }
    }

    public void addToQueue(Packet<?> packet) {
        Queue<Object> packets = null;
        if (this.queue.containsKey(this.ticks + this.delay.getValue())) {
            packets = this.queue.get(this.ticks + this.delay.getValue());
        } else {
            packets = new ArrayDeque();
            this.queue.put(this.ticks + this.delay.getValue(), packets);
        }
        packets.add(packet);
    }
}

