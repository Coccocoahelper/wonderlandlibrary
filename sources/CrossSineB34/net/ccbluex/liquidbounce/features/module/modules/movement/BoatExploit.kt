/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.movement

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.features.value.FloatValue
import net.ccbluex.liquidbounce.features.value.IntegerValue
import net.ccbluex.liquidbounce.features.value.ListValue
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.minecraft.entity.item.EntityBoat
import net.minecraft.network.play.client.C02PacketUseEntity
import net.minecraft.network.play.client.C0CPacketInput
import net.minecraft.util.Vec3
import kotlin.math.cos
import kotlin.math.sin

@ModuleInfo(name = "BoatExploit", "BoatExploit" ,category = ModuleCategory.MOVEMENT)
class BoatExploit : Module() {
    private val modeValue = ListValue("Mode", arrayOf("Boost", "Launch", "Matrix", "Motion", "Clip", "Velocity"), "Boost")
    private val speedValue = FloatValue("Speed", 0.3f, 0.0f, 1.0f).displayable { modeValue.equals("Motion") || modeValue.equals("Clip") || modeValue.equals("Velocity") }
    private val hBoostValue = FloatValue("HBoost", 2f, 0f, 6f).displayable { modeValue.equals("Boost") || modeValue.equals("Launch") }
    private val vBoostValue = FloatValue("VBoost", 2f, 0f, 6f).displayable { modeValue.equals("Boost") || modeValue.equals("Launch") }
    private val matrixTimerStartValue = FloatValue("MatrixTimerStart", 0.3f, 0.1f, 1f).displayable { modeValue.equals("Matrix") }
    private val matrixTimerAirValue = FloatValue("MatrixTimerAir", 0.5f, 0.1f, 1.5f).displayable { modeValue.equals("Matrix") }
    private val launchRadiusValue = FloatValue("LaunchRadius", 4F, 3F, 10F).displayable { modeValue.equals("Launch") }
    private val delayValue = IntegerValue("Delay", 200, 100, 500).displayable { modeValue.equals("Boost") || modeValue.equals("Launch") }
    private val autoHitValue = BoolValue("AutoHit", true).displayable { modeValue.equals("Boost") || modeValue.equals("Launch") }

    private var jumpState = 1
    private val timer = MSTimer()
    private val hitTimer = MSTimer()
    private var lastRide = false
    private var hasStopped = false

    override fun onEnable() {
        jumpState = 1
        lastRide = false
    }

    override fun onDisable() {
        hasStopped = false
        mc.timer.timerSpeed = 1f
        mc.thePlayer.speedInAir = 0.02f
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        // println(mc.timer.timerSpeed)
        if (mc.thePlayer.onGround && !mc.thePlayer.isRiding) {
            hasStopped = false
            mc.timer.timerSpeed = 1f
            mc.thePlayer.speedInAir = 0.02f
        }

        when (modeValue.get().lowercase()) {
            "matrix" -> {
                if (hasStopped) {
                    mc.timer.timerSpeed = matrixTimerAirValue.get()
                } else {
                    mc.timer.timerSpeed = 1f
                }
            }
        }

        if (mc.thePlayer.isRiding && jumpState == 1) {
            if (!lastRide) {
                timer.reset()
            }

            if (timer.hasTimePassed(delayValue.get().toLong())) {
                jumpState = 2
                when (modeValue.get().lowercase()) {
                    "matrix" -> {
                        mc.timer.timerSpeed = matrixTimerStartValue.get()
                        mc.netHandler.addToSendQueue(
                            C0CPacketInput(
                                mc.thePlayer.moveStrafing,
                                mc.thePlayer.moveForward,
                                false,
                                true
                            )
                        )
                    }
                    else -> {
                        mc.netHandler.addToSendQueue(
                            C0CPacketInput(
                                mc.thePlayer.moveStrafing,
                                mc.thePlayer.moveForward,
                                false,
                                true
                            )
                        )
                    }
                }
            }
        } else if (jumpState == 2 && !mc.thePlayer.isRiding) {
            val radiansYaw = mc.thePlayer.rotationYaw * Math.PI / 180

            when (modeValue.get().lowercase()) {
                "boost" -> {
                    mc.thePlayer.motionX = hBoostValue.get() * -sin(radiansYaw)
                    mc.thePlayer.motionZ = hBoostValue.get() * cos(radiansYaw)
                    mc.thePlayer.motionY = vBoostValue.get().toDouble()
                    jumpState = 1
                }
                "launch" -> {
                    mc.thePlayer.motionX += (hBoostValue.get() * 0.1) * -sin(radiansYaw)
                    mc.thePlayer.motionZ += (hBoostValue.get() * 0.1) * cos(radiansYaw)
                    mc.thePlayer.motionY += vBoostValue.get() * 0.1

                    var hasBoat = false
                    for (entity in mc.theWorld.loadedEntityList) {
                        if (entity is EntityBoat && mc.thePlayer.getDistanceToEntity(entity) < launchRadiusValue.get()) {
                            hasBoat = true
                            break
                        }
                    }
                    if (!hasBoat) {
                        jumpState = 1
                    }
                }
                "matrix" -> {
                    hasStopped = true
                    mc.timer.timerSpeed = matrixTimerAirValue.get()
                    mc.thePlayer.motionX = hBoostValue.get() * -sin(radiansYaw)
                    mc.thePlayer.motionZ = hBoostValue.get() * cos(radiansYaw)
                    mc.thePlayer.motionY = vBoostValue.get().toDouble()
                    jumpState = 1
                }
            }

            timer.reset()
            hitTimer.reset()
        }

        lastRide = mc.thePlayer.isRiding

        if (autoHitValue.get() && !mc.thePlayer.isRiding && hitTimer.hasTimePassed(1500)) {
            for (entity in mc.theWorld.loadedEntityList) {
                if (entity is EntityBoat && mc.thePlayer.getDistanceToEntity(entity) < 3) {
                    mc.netHandler.addToSendQueue(C02PacketUseEntity(entity, Vec3(0.5, 0.5, 0.5)))
                    mc.netHandler.addToSendQueue(C02PacketUseEntity(entity, C02PacketUseEntity.Action.INTERACT))
                    hitTimer.reset()
                }
            }
        }
        if(!mc.thePlayer.isRiding) return

        val vehicle = mc.thePlayer.ridingEntity
        val x = -sin(MovementUtils.direction) * speedValue.get()
        val z = cos(MovementUtils.direction) * speedValue.get()

        when (modeValue.get().lowercase()) {
            "motion" -> {
                vehicle.motionX = x
                vehicle.motionY = (if(mc.gameSettings.keyBindJump.pressed) speedValue.get() else 0).toDouble()
                vehicle.motionZ = z
            }

            "clip" -> {
                vehicle.setPosition(vehicle.posX + x , vehicle.posY + (if (mc.gameSettings.keyBindJump.pressed) speedValue.get() else 0).toDouble() , vehicle.posZ + z)
            }

            "velocity" -> {
                vehicle.addVelocity(x, if(mc.gameSettings.keyBindJump.pressed) speedValue.get().toDouble() else vehicle.motionY, z)
            }
        }
    }
}