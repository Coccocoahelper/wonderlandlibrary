package net.ccbluex.liquidbounce.features.module.modules.exploit;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import kotlin.Metadata;
import kotlin.Unit;
import kotlin.jvm.internal.Intrinsics;
import net.ccbluex.liquidbounce.api.MinecraftVersion;
import net.ccbluex.liquidbounce.api.minecraft.client.entity.IEntityPlayerSP;
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket;
import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.PacketEvent;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.MinecraftInstance;
import net.ccbluex.liquidbounce.utils.timer.TimeUtils;
import net.ccbluex.liquidbounce.value.IntegerValue;
import org.jetbrains.annotations.NotNull;

@ModuleInfo(name="PingSpoof", description="Spoofs your ping to a given value.", category=ModuleCategory.EXPLOIT, supportedVersions={MinecraftVersion.MC_1_8})
@Metadata(mv={1, 1, 16}, bv={1, 0, 3}, k=1, d1={"\u0000:\n\n\n\b\n\n\b\n\n\n\t\n\n\u0000\n\n\b\n\n\u0000\n\n\u0000\b\u000020BÂ¢J\b0\fHJ\r0\f20HJ0\f20HR0XÂ‚Â¢\n\u0000R0XÂ‚Â¢\n\u0000R*0\b0\t0j0\b0\t`\nXÂ‚Â¢\n\u0000Â¨"}, d2={"Lnet/ccbluex/liquidbounce/features/module/modules/exploit/PingSpoof;", "Lnet/ccbluex/liquidbounce/features/module/Module;", "()V", "maxDelayValue", "Lnet/ccbluex/liquidbounce/value/IntegerValue;", "minDelayValue", "packetQueue", "Ljava/util/HashMap;", "Lnet/ccbluex/liquidbounce/api/minecraft/network/IPacket;", "", "Lkotlin/collections/HashMap;", "onDisable", "", "onPacket", "event", "Lnet/ccbluex/liquidbounce/event/PacketEvent;", "onUpdate", "Lnet/ccbluex/liquidbounce/event/UpdateEvent;", "Pride"})
public final class PingSpoof
extends Module {
    private final IntegerValue minDelayValue = new IntegerValue(this, "MinDelay", 500, 0, 5000){
        final PingSpoof this$0;

        protected void onChanged(int oldValue, int newValue) {
            int maxDelayValue2 = ((Number)PingSpoof.access$getMaxDelayValue$p(this.this$0).get()).intValue();
            if (maxDelayValue2 < newValue) {
                this.set(maxDelayValue2);
            }
        }
        {
            this.this$0 = $outer;
            super($super_call_param$1, $super_call_param$2, $super_call_param$3, $super_call_param$4);
        }
    };
    private final IntegerValue maxDelayValue = new IntegerValue(this, "MaxDelay", 1000, 0, 5000){
        final PingSpoof this$0;

        protected void onChanged(int oldValue, int newValue) {
            int minDelayValue2 = ((Number)PingSpoof.access$getMinDelayValue$p(this.this$0).get()).intValue();
            if (minDelayValue2 > newValue) {
                this.set(minDelayValue2);
            }
        }
        {
            this.this$0 = $outer;
            super($super_call_param$1, $super_call_param$2, $super_call_param$3, $super_call_param$4);
        }
    };
    private final HashMap<IPacket, Long> packetQueue;

    @Override
    public void onDisable() {
        this.packetQueue.clear();
    }

    /*
     * WARNING - Removed try catching itself - possible behaviour change.
     */
    @EventTarget
    public final void onPacket(@NotNull PacketEvent event) {
        Intrinsics.checkParameterIsNotNull(event, "event");
        IPacket packet = event.getPacket();
        if (MinecraftInstance.classProvider.isCPacketKeepAlive(packet) || MinecraftInstance.classProvider.isCPacketClientStatus(packet)) {
            IEntityPlayerSP iEntityPlayerSP = MinecraftInstance.mc.getThePlayer();
            if (iEntityPlayerSP == null) {
                Intrinsics.throwNpe();
            }
            if (!iEntityPlayerSP.isDead()) {
                IEntityPlayerSP iEntityPlayerSP2 = MinecraftInstance.mc.getThePlayer();
                if (iEntityPlayerSP2 == null) {
                    Intrinsics.throwNpe();
                }
                if (!(iEntityPlayerSP2.getHealth() <= 0.0f) && !this.packetQueue.containsKey(packet)) {
                    event.cancelEvent();
                    HashMap<IPacket, Long> hashMap = this.packetQueue;
                    boolean bl = false;
                    boolean bl2 = false;
                    synchronized (hashMap) {
                        boolean bl3 = false;
                        ((Map)this.packetQueue).put(packet, System.currentTimeMillis() + TimeUtils.randomDelay(((Number)this.minDelayValue.get()).intValue(), ((Number)this.maxDelayValue.get()).intValue()));
                        Unit unit = Unit.INSTANCE;
                    }
                }
            }
        }
    }

    /*
     * WARNING - Removed try catching itself - possible behaviour change.
     * WARNING - void declaration
     */
    @EventTarget
    public final void onUpdate(@NotNull UpdateEvent event) {
        Intrinsics.checkParameterIsNotNull(event, "event");
        HashMap<IPacket, Long> hashMap = this.packetQueue;
        boolean bl = false;
        boolean bl2 = false;
        synchronized (hashMap) {
            void $this$filterTo$iv$iv;
            boolean bl3 = false;
            Map $this$filter$iv = this.packetQueue;
            boolean $i$f$filter = false;
            Map map = $this$filter$iv;
            Map destination$iv$iv = new LinkedHashMap();
            boolean $i$f$filterTo = false;
            void var11_15 = $this$filterTo$iv$iv;
            boolean bl4 = false;
            Iterator iterator = var11_15.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry element$iv$iv;
                Map.Entry it = element$iv$iv = iterator.next();
                boolean bl5 = false;
                if (!(((Number)it.getValue()).longValue() >= System.currentTimeMillis())) continue;
                destination$iv$iv.put(element$iv$iv.getKey(), element$iv$iv.getValue());
            }
            Map $this$forEach$iv = destination$iv$iv;
            boolean $i$f$forEach = false;
            map = $this$forEach$iv;
            boolean bl6 = false;
            Iterator iterator2 = map.entrySet().iterator();
            while (iterator2.hasNext()) {
                void packet;
                Map.Entry element$iv;
                Map.Entry $dstr$packet$time = element$iv = iterator2.next();
                boolean bl7 = false;
                Map.Entry entry = $dstr$packet$time;
                boolean bl8 = false;
                IPacket bl5 = (IPacket)entry.getKey();
                entry = $dstr$packet$time;
                bl8 = false;
                long time = ((Number)entry.getValue()).longValue();
                MinecraftInstance.mc.getNetHandler().addToSendQueue((IPacket)packet);
                this.packetQueue.remove(packet, time);
            }
            Unit unit = Unit.INSTANCE;
        }
    }

    public PingSpoof() {
        PingSpoof pingSpoof = this;
        boolean bl = false;
        HashMap hashMap = new HashMap();
        pingSpoof.packetQueue = hashMap;
    }

    public static final IntegerValue access$getMaxDelayValue$p(PingSpoof $this) {
        return $this.maxDelayValue;
    }

    public static final IntegerValue access$getMinDelayValue$p(PingSpoof $this) {
        return $this.minDelayValue;
    }
}
